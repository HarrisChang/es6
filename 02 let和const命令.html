<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>01 let & const</title>
</head>
<body>
<script>
    /*1. let命令*/

        //1.1基本用法
        /*var a = [];
        for(var i = 0; i < 10; i++){
            a[i] = function(){
                console.log(i);
            }
        }
        a[6]();     //10*/

        /*var a = [];
        for(let i = 0; i < 10; i++){
            a[i] = function(){
                console.log(i);
            }
        }
        a[6]();     //6*/

        //for循环有个特别之处，就是循环语句部分是一个父作用域，循环体内部是一个单独的子作用域
        /*for(let i = 0; i < 3; i++){
            let i = 'abc';
            console.log(i);
        }*/

        //1.2不存在变量提升
        /*console.log(foo);  //undefinded
        var foo = 32;

        console.log(bar);  //ReferenceError
        let bar = 23;*/

        //1.3暂时性死区(只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部的影响)
        //总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上成为“暂时性死区”
        /*var tmp = 123;
        if(true){
            tmp = 'abc';  //ReferenceError
            let tmp;
        }*/

        /*function bar(x = y, y = 2) {
            return [x, y];
        }
        bar();  //报错

        function foo(x = 2, y = x){
            return [x, y];
        }
        foo();*/

        //暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取。只有等到变量的那一行代码出现，才可获取和使用该变量。

    /*2块级作用域*/
        //2.1 ES5只有全局作用域和函数作用域
        /*var tmp = new Date();
        function f(){
            console.log(tmp);
            if(false){
                var tmp = "hello world!";
            }
        }
        f();  //undefined*/

        /*var s = "hello";
        for(var i = 0; i < s.length; i++){
            console.log(s[i]);
        }
        console.log(i);  //用来计数的循环变量泄露为全局变量*/

        //2.2 ES6的块级作用域
        /*function f(){ console.log("I am outside"); }
        (function(){
            if(false){
                function f(){ console.log("I am inside"); }
            }
            f();
        }());  //在ES6环境下，f is not a function*/

    /*3. do表达式*/
        /*{
            let t = f();
            t = t * t + 1;
        }
        //无法获取t的值*/

        /*let x = do {
            let t = 3;
            t * t + 1;
        };
        console.log(x);*/

    /*4. const命令(const声明一个只读的常量，一旦声明，常量的值就不能改变)*/
        //这就意味着const一旦声明变量，必须立即初始化，只声明不赋值会报错。
        /*const PI = 3.1415;
        PI  //3.1415
        PI = 3;  //Error*/

    /*5.顶层对象的属性*/
        //var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
        /*var a = 1;
        window.a  //1

        let b = 2;
        window.b  //undefined*/
</script>
</body>
</html>